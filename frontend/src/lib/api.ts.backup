/**
 * Wails invoke function wrapper
 *
 * In Wails, backend functions are exposed via generated bindings in wailsjs/go/
 * For now, we'll create a placeholder that matches Tauri's invoke signature.
 * TODO: Replace with actual Wails backend bindings when they're generated.
 */
async function invoke<T>(command: string, args?: Record<string, unknown>): Promise<T> {
  // TODO: Map command names to actual Wails backend function calls
  // For now, log the attempt
  console.warn(`invoke('${command}') called - needs Wails backend implementation`, args);
  throw new Error(`Backend function '${command}' not yet implemented in Wails`);
}

import type { HooksConfiguration } from '@/types/hooks';

/** Process type for tracking in ProcessRegistry */
export type ProcessType =
  | { AgentRun: { agent_id: number; agent_name: string } }
  | { ClaudeSession: { session_id: string } };

/** Information about a running process */
export interface ProcessInfo {
  run_id: number;
  process_type: ProcessType;
  pid: number;
  started_at: string;
  project_path: string;
  task: string;
  model: string;
}

/** Lightweight message metadata for indexing */
export interface MessageIndex {
  line_number: number;
  byte_offset: number;
  byte_length: number;
  timestamp?: string;
  message_type?: string;
}

/**
 * Represents a project in the ~/.claude/projects directory
 */
export interface Project {
  /** The project ID (derived from the directory name) */
  id: string;
  /** The original project path (decoded from the directory name) */
  path: string;
  /** List of session IDs (JSONL file names without extension) */
  sessions: string[];
  /** Unix timestamp when the project directory was created */
  created_at: number;
  /** Unix timestamp of the most recent session (if any) */
  most_recent_session?: number;
  /** Optional list of workspaces for this project */
  workspaces?: ProjectIndex[];
  /** Last used provider ID */
  last_provider?: string;
  /** Provider-specific paths and IDs (for session_id access) */
  providers?: ProjectProvider[];
  /** Project type: default | ssh */
  project_type?: string;
  /** Whether the project has git support (detected via git2) */
  has_git_support?: boolean;
  /** SSH remote path */
  ssh_remote_path?: string;
  /** SSH connection name */
  ssh_connection_name?: string;
}

/**
 * Represents a provider-specific project path entry
 */
export interface ProjectProvider {
  /** Provider ID (e.g., "claude", "codex") */
  provider_id: string;
  /** The project path for this provider */
  path: string;
  /** Provider-specific project ID */
  id: string;
  /** Optional provider API configuration ID to use for this provider */
  provider_api_id?: string;
  /** Active session ID for this provider (optional) */
  session_id?: string;
}

/**
 * SSH authentication method
 */
export type SSHAuthMethod =
  | { type: 'password'; password: string }
  | { type: 'privateKey'; keyPath: string; passphrase?: string };

/**
 * Configuration for SSH connection and project sync
 */
export interface SSHConfig {
  /** SSH server host */
  host: string;
  /** SSH server port (default: 22) */
  port: number;
  /** SSH username */
  username: string;
  /** Authentication method */
  authMethod: SSHAuthMethod;
  /** Remote project path */
  remotePath: string;
  /** Local target path */
  localPath: string;
  /** Patterns to skip during sync (e.g., [".git", "node_modules"]) */
  skipPatterns: string[];
  /** Optional connection name selected from presets */
  connectionName?: string;
  /** Sync direction for initial sync: 'pull' (remote→local) or 'push' (local→remote). Default: 'pull' */
  syncDirection?: 'pull' | 'push';
  /** Auto sync direction: 'local-priority' (push only) or 'bidirectional' (two-way sync). Default: 'local-priority' */
  autoSyncDirection?: 'local-priority' | 'bidirectional';
}

/**
 * Progress information for SSH sync operation
 */
export interface SSHSyncProgress {
  /** Current stage of the sync process */
  stage: 'connecting' | 'authenticating' | 'downloading' | 'completed' | 'error';
  /** Progress percentage (0-100) */
  percentage: number;
  /** Number of files processed */
  filesProcessed: number;
  /** Total number of files */
  totalFiles: number;
  /** Bytes downloaded */
  bytesDownloaded: number;
  /** Total bytes to download */
  totalBytes: number;
  /** Current file being processed */
  currentFile?: string;
  /** Error message if stage is 'error' */
  error?: string;
  /** Operation direction for current file */
  direction?: 'download' | 'upload';
  /** Sync session id for control */
  syncId?: string;
  /** Whether current state is paused */
  isPaused?: boolean;
  /** Local project path this sync operates on */
  projectPath?: string;
}

/**
 * Auto sync status for a project
 */
export interface AutoSyncStatus {
  /** Project ID */
  projectId: string;
  /** Whether auto sync is currently running */
  isRunning: boolean;
  /** Unix timestamp of last successful sync */
  lastSyncTime?: number;
  /** Error message if any */
  error?: string;
}

/**
 * Configuration for Git clone operation
 */
export interface GitCloneConfig {
  /** Repository URL (HTTPS or SSH) */
  url: string;
  /** Local path to clone into */
  localPath: string;
  /** Optional branch to checkout */
  branch?: string;
}

/**
 * Progress information for Git clone operation
 */
export interface GitCloneProgress {
  /** Current stage of the clone process */
  stage: 'initializing' | 'cloning' | 'resolving' | 'completed' | 'error';
  /** Progress percentage (0-100) */
  percentage: number;
  /** Number of objects received */
  objectsReceived: number;
  /** Total number of objects */
  totalObjects: number;
  /** Bytes received */
  bytesReceived: number;
  /** Current operation description */
  currentOperation?: string;
  /** Error message if stage is 'error' */
  error?: string;
}

/**
 * Represents a provider API configuration (e.g., different Anthropic API endpoints)
 */
export interface ProviderApiConfig {
  /** Unique identifier for this API configuration */
  id: string;
  /** Display name for this API configuration */
  name: string;
  /** Provider this API configuration belongs to (e.g., "claude") */
  provider_id: string;
  /** API endpoint base URL (non-environment variable) */
  base_url?: string;
  /** API authentication token (non-environment variable, will be passed as env var when needed) */
  auth_token?: string;
  /** Whether this is the default API for this provider */
  is_default: boolean;
  /** Whether this is a built-in configuration (cannot be deleted) */
  is_builtin: boolean;
  /** Created timestamp */
  created_at: number;
  /** Last updated timestamp */
  updated_at: number;
}

/**
 * Represents an action (script/command) that can be executed
 */
export interface Action {
  /** Unique identifier */
  id: string;
  /** Display name */
  name: string;
  /** Command to execute (for script actions) or URL to open (for web actions) */
  command: string;
  /** Optional description */
  description?: string;
  /** Optional icon (emoji or lucide icon name) */
  icon?: string;
  /** Action type: "global", "project" or "workspace" */
  type: 'global' | 'project' | 'workspace';
  /** Whether this action is shared (only for project-level actions) */
  shared?: boolean;
  /** Optional keyboard shortcut */
  shortcut?: string;
  /** Action execution type: "script" (run command) or "web" (open webview) */
  actionType?: 'script' | 'web';
}

/**
 * Represents a workspace with provider support
 */
export interface WorkspaceIndex {
  /** Workspace name */
  name: string;
  /** Unix timestamp when the workspace was added to index */
  added_at: number;
  /** Provider-specific paths and IDs for this workspace */
  providers: ProjectProvider[];
  /** The last used provider ID */
  last_provider: string;
  /** Git branch name for this workspace */
  branch?: string;
  /** Workspace-specific actions */
  actions?: Action[];
}

/**
 * Represents a project index entry stored in ~/.opcode/projects.json
 */
export interface ProjectIndex {
  /** The project display name (extracted from path) */
  name: string;
  /** Unix timestamp when the project was added to index */
  added_at: number;
  /** Unix timestamp of the most recent access */
  last_accessed: number;
  /** Optional description or tags */
  description?: string;
  /** Whether this project is currently available */
  available: boolean;
  /** Provider-specific paths and IDs */
  providers: ProjectProvider[];
  /** List of workspaces for this project */
  workspaces: WorkspaceIndex[];
  /** The last used provider ID */
  last_provider: string;
  /** Optional branch name (if this is a workspace) */
  branch?: string;
  /** Project-level actions */
  actions?: Action[];
  /** Saved SSH connections for this project */
  ssh_configs?: any[];
  /** Project type: default | ssh */
  project_type?: string;
  /** Whether the project has git support (detected via git2) */
  has_git_support?: boolean;
  /** SSH remote path (if SSH project) */
  ssh_remote_path?: string;
  /** SSH connection name (if SSH project) */
  ssh_connection_name?: string;
}

/**
 * Represents a session with its metadata
 */
export interface Session {
  /** The session ID (UUID) */
  id: string;
  /** The project ID this session belongs to */
  project_id: string;
  /** The project path */
  project_path: string;
  /** Optional todo data associated with this session */
  todo_data?: any;
  /** Unix timestamp when the session file was created */
  created_at: number;
  /** First user message content (if available) */
  first_message?: string;
  /** Timestamp of the first user message (if available) */
  message_timestamp?: string;
}

/**
 * Represents the settings from ~/.claude/settings.json
 */
export interface ClaudeSettings {
  [key: string]: any;
}

/**
 * Represents the Claude Code version status
 */
export interface ClaudeVersionStatus {
  /** Whether Claude Code is installed and working */
  is_installed: boolean;
  /** The version string if available */
  version?: string;
  /** The full output from the command */
  output: string;
}

/**
 * Represents a CLAUDE.md file found in the project
 */
export interface ClaudeMdFile {
  /** Relative path from the project root */
  relative_path: string;
  /** Absolute path to the file */
  absolute_path: string;
  /** File size in bytes */
  size: number;
  /** Last modified timestamp */
  modified: number;
}

/**
 * Represents a file, directory, or agent entry
 */
export interface FileEntry {
  name: string;
  path: string;
  is_directory: boolean;
  size: number;
  extension?: string;
  entry_type?: "file" | "agent"; // Default is "file" for backward compatibility
  agent_id?: number; // Only present when entry_type is "agent"
  icon?: string; // Only present when entry_type is "agent"
  color?: string; // Only present when entry_type is "agent" - color from agent frontmatter
}

/**
 * Represents a Claude installation found on the system
 */
export interface ClaudeInstallation {
  /** Full path to the Claude binary */
  path: string;
  /** Version string if available */
  version?: string;
  /** Source of discovery (e.g., "nvm", "system", "homebrew", "which") */
  source: string;
  /** Type of installation */
  installation_type: "System" | "Custom";
}

// Agent API types (CC Agents - stored in SQLite)
export interface Agent {
  id?: number;
  name: string;
  icon: string;
  system_prompt: string;
  default_task?: string;
  model: string;
  provider_api_id?: string; // Optional provider API configuration ID
  hooks?: string; // JSON string of HooksConfiguration
  created_at: string;
  updated_at: string;
}

// Claude Agent types (Claude Code agents - stored in ~/.claude/agents/*.md)
export interface ClaudeAgent {
  /** Agent name (unique identifier) */
  name: string;
  /** Agent description */
  description: string;
  /** Optional tools list (comma-separated) */
  tools?: string;
  /** Optional color */
  color?: string;
  /** Optional model */
  model?: string;
  /** System prompt (Markdown content) */
  system_prompt: string;
  /** Scope: "user" or "project" */
  scope: string;
  /** Full file path */
  file_path: string;
}

// Plugin types

/** Plugin author information */
export interface PluginAuthor {
  name: string;
  email?: string;
}

/** Plugin metadata from .claude-plugin/plugin.json */
export interface PluginMetadata {
  name: string;
  description?: string;
  version?: string;
  author?: PluginAuthor;
  homepage?: string;
  repository?: string;
  license?: string;
  keywords: string[];
}

/** Installed plugin information */
export interface InstalledPlugin {
  /** Plugin identifier (e.g., "superpowers@superpowers-marketplace") */
  id: string;
  /** Short name (e.g., "superpowers") */
  name: string;
  /** Marketplace name (e.g., "superpowers-marketplace") */
  marketplace?: string;
  version: string;
  installed_at: string;
  last_updated: string;
  install_path: string;
  git_commit_sha?: string;
  is_local: boolean;
  /** Plugin metadata from plugin.json */
  metadata?: PluginMetadata;
}

/** Plugin agent (from plugin's agents/*.md) */
export interface PluginAgent {
  name: string;
  description: string;
  tools?: string;
  color?: string;
  model?: string;
  system_prompt: string;
  plugin_id: string;
  plugin_name: string;
  file_path: string;
}

/** Plugin command (from plugin's commands/*.md) */
export interface PluginCommand {
  name: string;
  description?: string;
  allowed_tools?: string;
  content: string;
  plugin_id: string;
  plugin_name: string;
  file_path: string;
  /** Full command with plugin prefix (e.g., "/superpowers:brainstorm") */
  full_command: string;
}

/** Plugin skill (from plugin's skills/[name]/SKILL.md) */
export interface PluginSkill {
  name: string;
  description?: string;
  content: string;
  plugin_id: string;
  plugin_name: string;
  folder_path: string;
}

/** Plugin hook configuration */
export interface PluginHook {
  event_type: string;
  matcher?: string;
  command: string;
  plugin_id: string;
  plugin_name: string;
}

/** Full plugin contents */
export interface PluginContents {
  plugin: InstalledPlugin;
  agents: PluginAgent[];
  commands: PluginCommand[];
  skills: PluginSkill[];
  hooks: PluginHook[];
}

export interface AgentExport {
  version: number;
  exported_at: string;
  agent: {
    name: string;
    icon: string;
    system_prompt: string;
    default_task?: string;
    model: string;
    hooks?: string;
  };
}

export interface GitHubAgentFile {
  name: string;
  path: string;
  download_url: string;
  size: number;
  sha: string;
}

export interface AgentRun {
  id?: number;
  agent_id: number;
  agent_name: string;
  agent_icon: string;
  task: string;
  model: string;
  project_path: string;
  session_id: string;
  status: string; // 'pending', 'running', 'completed', 'failed', 'cancelled'
  pid?: number;
  process_started_at?: string;
  created_at: string;
  completed_at?: string;
}

export interface AgentRunMetrics {
  duration_ms?: number;
  total_tokens?: number;
  cost_usd?: number;
  message_count?: number;
}

export interface AgentRunWithMetrics {
  id?: number;
  agent_id: number;
  agent_name: string;
  agent_icon: string;
  task: string;
  model: string;
  project_path: string;
  session_id: string;
  status: string; // 'pending', 'running', 'completed', 'failed', 'cancelled'
  pid?: number;
  duration_ms?: number;
  total_tokens?: number;
  process_started_at?: string;
  created_at: string;
  completed_at?: string;
  metrics?: AgentRunMetrics;
  output?: string; // Real-time JSONL content
}

// Usage Dashboard types
export interface UsageEntry {
  project: string;
  timestamp: string;
  model: string;
  input_tokens: number;
  output_tokens: number;
  cache_write_tokens: number;
  cache_read_tokens: number;
  cost: number;
}

export interface ModelUsage {
  model: string;
  total_cost: number;
  total_tokens: number;
  input_tokens: number;
  output_tokens: number;
  cache_creation_tokens: number;
  cache_read_tokens: number;
  session_count: number;
}

export interface DailyUsage {
  date: string;
  total_cost: number;
  total_tokens: number;
  models_used: string[];
}

export interface ProjectUsage {
  project_path: string;
  project_name: string;
  total_cost: number;
  total_tokens: number;
  session_count: number;
  last_used: string;
}

export interface UsageStats {
  total_cost: number;
  total_tokens: number;
  total_input_tokens: number;
  total_output_tokens: number;
  total_cache_creation_tokens: number;
  total_cache_read_tokens: number;
  total_sessions: number;
  by_model: ModelUsage[];
  by_date: DailyUsage[];
  by_project: ProjectUsage[];
}

/**
 * Represents a checkpoint in the session timeline
 */
export interface Checkpoint {
  id: string;
  sessionId: string;
  projectId: string;
  messageIndex: number;
  timestamp: string;
  description?: string;
  parentCheckpointId?: string;
  metadata: CheckpointMetadata;
}

/**
 * Metadata associated with a checkpoint
 */
export interface CheckpointMetadata {
  totalTokens: number;
  modelUsed: string;
  userPrompt: string;
  fileChanges: number;
  snapshotSize: number;
}

/**
 * Represents a file snapshot at a checkpoint
 */
export interface FileSnapshot {
  checkpointId: string;
  filePath: string;
  content: string;
  hash: string;
  isDeleted: boolean;
  permissions?: number;
  size: number;
}

/**
 * Represents a node in the timeline tree
 */
export interface TimelineNode {
  checkpoint: Checkpoint;
  children: TimelineNode[];
  fileSnapshotIds: string[];
}

/**
 * The complete timeline for a session
 */
export interface SessionTimeline {
  sessionId: string;
  rootNode?: TimelineNode;
  currentCheckpointId?: string;
  autoCheckpointEnabled: boolean;
  checkpointStrategy: CheckpointStrategy;
  totalCheckpoints: number;
}

/**
 * Strategy for automatic checkpoint creation
 */
export type CheckpointStrategy = 'manual' | 'per_prompt' | 'per_tool_use' | 'smart';

/**
 * Result of a checkpoint operation
 */
export interface CheckpointResult {
  checkpoint: Checkpoint;
  filesProcessed: number;
  warnings: string[];
}

/**
 * Diff between two checkpoints
 */
export interface CheckpointDiff {
  fromCheckpointId: string;
  toCheckpointId: string;
  modifiedFiles: FileDiff[];
  addedFiles: string[];
  deletedFiles: string[];
  tokenDelta: number;
}

/**
 * Diff for a single file
 */
export interface FileDiff {
  path: string;
  additions: number;
  deletions: number;
  diffContent?: string;
}

/**
 * Represents an MCP server configuration
 */
export interface MCPServer {
  /** Server name/identifier */
  name: string;
  /** Transport type: "stdio" or "sse" */
  transport: string;
  /** Command to execute (for stdio) */
  command?: string;
  /** Command arguments (for stdio) */
  args: string[];
  /** Environment variables */
  env: Record<string, string>;
  /** URL endpoint (for SSE) */
  url?: string;
  /** Configuration scope: "local", "project", or "user" */
  scope: string;
  /** Whether the server is currently active */
  is_active: boolean;
  /** Server status */
  status: ServerStatus;
}

/**
 * Server status information
 */
export interface ServerStatus {
  /** Whether the server is running */
  running: boolean;
  /** Last error message if any */
  error?: string;
  /** Last checked timestamp */
  last_checked?: number;
}

/**
 * MCP configuration for project scope (.mcp.json)
 */
export interface MCPProjectConfig {
  mcpServers: Record<string, MCPServerConfig>;
}

/**
 * Individual server configuration in .mcp.json
 */
export interface MCPServerConfig {
  command: string;
  args: string[];
  env: Record<string, string>;
}

/**
 * Command type: "claude" or "codex"
 */
export type CommandType = "claude" | "codex";

/**
 * Represents a custom slash command
 */
export interface SlashCommand {
  /** Unique identifier for the command */
  id: string;
  /** Command type: "claude" or "codex" */
  command_type: CommandType;
  /** Command name (without prefix) */
  name: string;
  /** Full command with prefix (e.g., "/project:optimize") */
  full_command: string;
  /** Command scope: "project", "user", or "plugin" */
  scope: string;
  /** Optional namespace (e.g., "frontend" in "/project:frontend:component") */
  namespace?: string;
  /** Path to the markdown file */
  file_path: string;
  /** Command content (markdown body) */
  content: string;
  /** Optional description from frontmatter */
  description?: string;
  /** Allowed tools from frontmatter (Claude only) */
  allowed_tools: string[];
  /** Argument hint from frontmatter (Codex only) */
  argument_hint?: string;
  /** Whether the command has bash commands (!) */
  has_bash_commands: boolean;
  /** Whether the command has file references (@) */
  has_file_references: boolean;
  /** Whether the command uses $ARGUMENTS placeholder */
  accepts_arguments: boolean;
  /** Plugin ID if command is from a plugin (e.g., "superpowers@superpowers-marketplace") */
  plugin_id?: string;
  /** Plugin name if command is from a plugin (e.g., "superpowers") */
  plugin_name?: string;
}

/**
 * Skill scope: plugin, user, or project
 */
export type SkillScope = "plugin" | "user" | "project";

/**
 * Represents a skill from any source (plugin, user, or project)
 */
export interface Skill {
  /** Unique identifier (e.g., "plugin:superpowers:brainstorming" or "user:my-skill") */
  id: string;
  /** Skill name (e.g., "brainstorming") */
  name: string;
  /** Full skill reference for display (e.g., ":superpowers:brainstorming") */
  full_name: string;
  /** Skill description */
  description?: string;
  /** Skill scope: plugin, user, or project */
  scope: SkillScope;
  /** Plugin ID if from a plugin (e.g., "superpowers@superpowers-marketplace") */
  plugin_id?: string;
  /** Plugin name if from a plugin (e.g., "superpowers") */
  plugin_name?: string;
  /** Path to the skill folder or file */
  path: string;
  /** Skill content (markdown body) */
  content: string;
  /** Allowed tools from frontmatter */
  allowed_tools: string[];
}

/**
 * Result of adding a server
 */
export interface AddServerResult {
  success: boolean;
  message: string;
  server_name?: string;
}

/**
 * Import result for multiple servers
 */
export interface ImportResult {
  imported_count: number;
  failed_count: number;
  servers: ImportServerResult[];
}

/**
 * Result for individual server import
 */
export interface ImportServerResult {
  name: string;
  success: boolean;
  error?: string;
}

/**
 * Worktree information from Git
 */
export interface WorktreeInfo {
  /** 当前工作目录 (子路径) */
  currentPath: string;
  /** Git 仓库根路径 (主 worktree) */
  rootPath: string;
  /** 母分支名称 */
  mainBranch: string;
  /** 是否为 worktree 子分支 */
  isWorktreeChild: boolean;
}

/**
 * API client for interacting with the Rust backend
 */
export const api = {
  /**
   * Gets the user's home directory path
   * @returns Promise resolving to the home directory path
   */
  async getHomeDirectory(): Promise<string> {
    try {
      return await invoke<string>("get_home_directory");
    } catch (error) {
      console.error("Failed to get home directory:", error);
      return "/";
    }
  },

  /**
   * Lists all projects in the ~/.claude/projects directory
   * @returns Promise resolving to an array of projects
   */
  async listProjects(): Promise<Project[]> {
    try {
      return await invoke<Project[]>("list_projects");
    } catch (error) {
      console.error("Failed to list projects:", error);
      throw error;
    }
  },

  /**
   * Adds a project to the index stored in ~/.opcode/projects.json
   * @param projectPath The path of the project to add
   * @returns Promise resolving to the project index entry
   */
  async addProjectToIndex(projectPath: string): Promise<ProjectIndex> {
    try {
      return await invoke<ProjectIndex>("add_project_to_index", {
        projectPath
      });
    } catch (error) {
      console.error("Failed to add project to index:", error);
      throw error;
    }
  },

  /**
   * Removes a project from the index stored in ~/.opcode/projects.json
   * This only removes the project from the index, it does NOT delete any files from disk
   * @param projectId The ID of the project to remove
   * @returns Promise that resolves when the removal is complete
   */
  async removeProjectFromIndex(projectId: string): Promise<void> {
    try {
      await invoke<void>("remove_project_from_index", {
        projectId
      });
    } catch (error) {
      console.error("Failed to remove project from index:", error);
      throw error;
    }
  },

  /**
   * Updates the last accessed time for a project in the index
   * @param projectId The ID of the project to update
   * @returns Promise that resolves when the update is complete
   */
  async updateProjectAccessTime(projectId: string): Promise<void> {
    try {
      await invoke<void>("update_project_access_time", {
        projectId
      });
    } catch (error) {
      console.error("Failed to update project access time:", error);
      throw error;
    }
  },

  /**
   * Adds a provider to an existing project
   * @param projectPath The path of the project
   * @param providerId The ID of the provider to add (e.g., "claude", "codex")
   * @returns Promise that resolves when the provider is added
   */
  async addProviderToProject(projectPath: string, providerId: string): Promise<void> {
    try {
      await invoke<void>("add_provider_to_project", {
        projectPath,
        providerId
      });
    } catch (error) {
      console.error("Failed to add provider to project:", error);
      throw error;
    }
  },

  /**
   * Updates the last used provider for a project
   * @param projectPath The path of the project
   * @param providerId The ID of the provider to set as last used
   * @returns Promise that resolves when the update is complete
   */
  async updateProjectLastProvider(projectPath: string, providerId: string): Promise<void> {
    try {
      await invoke<void>("update_project_last_provider", {
        projectPath,
        providerId
      });
    } catch (error) {
      console.error("Failed to update project last provider:", error);
      throw error;
    }
  },

  /**
   * Updates the last used provider for a workspace
   * @param workspacePath The path of the workspace
   * @param providerId The ID of the provider to set as last used
   * @returns Promise that resolves when the update is complete
   */
  async updateWorkspaceLastProvider(workspacePath: string, providerId: string): Promise<void> {
    try {
      await invoke<void>("update_workspace_last_provider", {
        workspacePath,
        providerId
      });
    } catch (error) {
      console.error("Failed to update workspace last provider:", error);
      throw error;
    }
  },

  /**
   * Updates the session_id for a specific provider
   * This is the unified interface for managing active sessions
   * @param path The project/workspace path
   * @param providerId The provider ID (e.g., "claude", "codex")
   * @param sessionId The session ID to set
   * @returns Promise that resolves when the update is complete
   */
  async updateProviderSession(
    path: string,
    providerId: string,
    sessionId: string
  ): Promise<void> {
    try {
      await invoke<void>("update_provider_session", {
        path,
        providerId,
        sessionId
      });
    } catch (error) {
      console.error("Failed to update provider session:", error);
      throw error;
    }
  },

  /**
   * Unified interface for updating project fields
   * Replaces multiple individual update functions
   * @param path The project path
   * @param updates Fields to update
   * @returns Promise that resolves when the update is complete
   */
  async updateProjectFields(
    path: string,
    updates: {
      last_accessed?: number;
      last_provider?: string;
      description?: string;
      project_type?: string;
      ssh_remote_path?: string;
      ssh_connection_name?: string;
    }
  ): Promise<void> {
    try {
      await invoke<void>("update_project_fields", {
        path,
        updates
      });
    } catch (error) {
      console.error("Failed to update project fields:", error);
      throw error;
    }
  },

  /**
   * Unified interface for updating workspace fields
   * Replaces multiple individual update functions
   * @param path The workspace path
   * @param updates Fields to update
   * @returns Promise that resolves when the update is complete
   */
  async updateWorkspaceFields(
    path: string,
    updates: {
      last_provider?: string;
      branch?: string;
    }
  ): Promise<void> {
    try {
      await invoke<void>("update_workspace_fields", {
        path,
        updates
      });
    } catch (error) {
      console.error("Failed to update workspace fields:", error);
      throw error;
    }
  },

  /**
   * Creates a new project for the given directory path
   * @param path - The directory path to create a project for
   * @returns Promise resolving to the created project
   */
  async createProject(path: string): Promise<Project> {
    try {
      return await invoke<Project>('create_project', { path });
    } catch (error) {
      console.error("Failed to create project:", error);
      throw error;
    }
  },

  /**
   * Retrieves sessions for a specific project
   * @param projectId - The ID of the project to retrieve sessions for
   * @returns Promise resolving to an array of sessions
   */
  async getProjectSessions(projectId: string): Promise<Session[]> {
    try {
      return await invoke<Session[]>('get_project_sessions', { projectId });
    } catch (error) {
      console.error("Failed to get project sessions:", error);
      throw error;
    }
  },

  /**
   * Creates a new workspace using git worktree
   * @param parentProjectPath - The path of the parent project
   * @param branchName - The name of the branch to create
   * @param workspaceName - Optional custom name for the workspace
   * @returns Promise resolving to the created workspace index entry
   */
  async createWorkspace(
    parentProjectPath: string,
    branchName: string,
    workspaceName?: string
  ): Promise<ProjectIndex> {
    try {
      return await invoke<ProjectIndex>('create_workspace', {
        parentProjectPath,
        branchName,
        workspaceName,
      });
    } catch (error) {
      console.error('Failed to create workspace:', error);
      throw error;
    }
  },

  /**
   * Removes a workspace and cleans up git worktree
   * @param workspaceId - The ID of the workspace to remove
   * @returns Promise that resolves when the workspace is removed
   */
  async removeWorkspace(workspaceId: string): Promise<void> {
    try {
      await invoke<void>('remove_workspace', { workspaceId });
    } catch (error) {
      console.error('Failed to remove workspace:', error);
      throw error;
    }
  },

  /**
   * Fetch list of agents from GitHub repository
   * @returns Promise resolving to list of available agents on GitHub
   */
  async fetchGitHubAgents(): Promise<GitHubAgentFile[]> {
    try {
      return await invoke<GitHubAgentFile[]>('fetch_github_agents');
    } catch (error) {
      console.error("Failed to fetch GitHub agents:", error);
      throw error;
    }
  },

  /**
   * Fetch and preview a specific agent from GitHub
   * @param downloadUrl - The download URL for the agent file
   * @returns Promise resolving to the agent export data
   */
  async fetchGitHubAgentContent(downloadUrl: string): Promise<AgentExport> {
    try {
      return await invoke<AgentExport>('fetch_github_agent_content', { downloadUrl });
    } catch (error) {
      console.error("Failed to fetch GitHub agent content:", error);
      throw error;
    }
  },

  /**
   * Import an agent directly from GitHub
   * @param downloadUrl - The download URL for the agent file
   * @returns Promise resolving to the imported agent
   */
  async importAgentFromGitHub(downloadUrl: string): Promise<Agent> {
    try {
      return await invoke<Agent>('import_agent_from_github', { downloadUrl });
    } catch (error) {
      console.error("Failed to import agent from GitHub:", error);
      throw error;
    }
  },

  // ==================== Claude Config Agents API ====================

  /**
   * Lists all Claude agents (user + project)
   * @param projectPath - Optional project path to include project-level agents
   * @returns Promise resolving to array of Claude agents
   */
  async listClaudeConfigAgents(projectPath?: string): Promise<ClaudeAgent[]> {
    try {
      return await invoke<ClaudeAgent[]>('list_claude_code_agents', { projectPath });
    } catch (error) {
      console.error("Failed to list Claude config agents:", error);
      throw error;
    }
  },

  /**
   * Gets a single Claude agent
   * @param scope - "user" or "project"
   * @param name - Agent name
   * @param projectPath - Required for project-scope agents
   * @returns Promise resolving to the Claude agent
   */
  async getClaudeAgent(scope: string, name: string, projectPath?: string): Promise<ClaudeAgent> {
    try {
      return await invoke<ClaudeAgent>('get_claude_agent', { scope, name, projectPath });
    } catch (error) {
      console.error("Failed to get Claude agent:", error);
      throw error;
    }
  },

  /**
   * Saves a Claude agent (create or update)
   * @param agent - The agent data to save
   * @param projectPath - Required for project-scope agents
   * @returns Promise that resolves when saved
   */
  async saveClaudeAgent(agent: ClaudeAgent, projectPath?: string): Promise<void> {
    try {
      await invoke<void>('save_claude_agent', { agent, projectPath });
    } catch (error) {
      console.error("Failed to save Claude agent:", error);
      throw error;
    }
  },

  /**
   * Deletes a Claude agent
   * @param scope - "user" or "project"
   * @param name - Agent name
   * @param projectPath - Required for project-scope agents
   * @returns Promise that resolves when deleted
   */
  async deleteClaudeAgent(scope: string, name: string, projectPath?: string): Promise<void> {
    try {
      await invoke<void>('delete_claude_agent', { scope, name, projectPath });
    } catch (error) {
      console.error("Failed to delete Claude agent:", error);
      throw error;
    }
  },

  // ============================================
  // Plugin Management APIs
  // ============================================

  /**
   * Lists all installed Claude Code plugins
   * @returns Promise resolving to an array of installed plugins
   */
  async listInstalledPlugins(): Promise<InstalledPlugin[]> {
    try {
      return await invoke<InstalledPlugin[]>('list_installed_plugins');
    } catch (error) {
      console.error("Failed to list installed plugins:", error);
      throw error;
    }
  },

  /**
   * Gets details of a specific plugin
   * @param pluginId - Plugin identifier (e.g., "superpowers@superpowers-marketplace")
   * @returns Promise resolving to plugin details
   */
  async getPluginDetails(pluginId: string): Promise<InstalledPlugin> {
    try {
      return await invoke<InstalledPlugin>('get_plugin_details', { pluginId });
    } catch (error) {
      console.error("Failed to get plugin details:", error);
      throw error;
    }
  },

  /**
   * Lists all agents from installed plugins
   * @param pluginId - Optional plugin ID to filter by
   * @returns Promise resolving to an array of plugin agents
   */
  async listPluginAgents(pluginId?: string): Promise<PluginAgent[]> {
    try {
      return await invoke<PluginAgent[]>('list_plugin_agents', { pluginId });
    } catch (error) {
      console.error("Failed to list plugin agents:", error);
      throw error;
    }
  },

  /**
   * Lists all commands from installed plugins
   * @param pluginId - Optional plugin ID to filter by
   * @returns Promise resolving to an array of plugin commands
   */
  async listPluginCommands(pluginId?: string): Promise<PluginCommand[]> {
    try {
      return await invoke<PluginCommand[]>('list_plugin_commands', { pluginId });
    } catch (error) {
      console.error("Failed to list plugin commands:", error);
      throw error;
    }
  },

  /**
   * Lists all skills from installed plugins
   * @param pluginId - Optional plugin ID to filter by
   * @returns Promise resolving to an array of plugin skills
   */
  async listPluginSkills(pluginId?: string): Promise<PluginSkill[]> {
    try {
      return await invoke<PluginSkill[]>('list_plugin_skills', { pluginId });
    } catch (error) {
      console.error("Failed to list plugin skills:", error);
      throw error;
    }
  },

  /**
   * Lists all hooks from installed plugins
   * @param pluginId - Optional plugin ID to filter by
   * @returns Promise resolving to an array of plugin hooks
   */
  async listPluginHooks(pluginId?: string): Promise<PluginHook[]> {
    try {
      return await invoke<PluginHook[]>('list_plugin_hooks', { pluginId });
    } catch (error) {
      console.error("Failed to list plugin hooks:", error);
      throw error;
    }
  },

  /**
   * Gets a single plugin agent by plugin ID and agent name
   * @param pluginId - Plugin identifier
   * @param agentName - Agent name
   * @returns Promise resolving to the plugin agent
   */
  async getPluginAgent(pluginId: string, agentName: string): Promise<PluginAgent> {
    try {
      return await invoke<PluginAgent>('get_plugin_agent', { pluginId, agentName });
    } catch (error) {
      console.error("Failed to get plugin agent:", error);
      throw error;
    }
  },

  /**
   * Gets a single plugin command by plugin ID and command name
   * @param pluginId - Plugin identifier
   * @param commandName - Command name
   * @returns Promise resolving to the plugin command
   */
  async getPluginCommand(pluginId: string, commandName: string): Promise<PluginCommand> {
    try {
      return await invoke<PluginCommand>('get_plugin_command', { pluginId, commandName });
    } catch (error) {
      console.error("Failed to get plugin command:", error);
      throw error;
    }
  },

  /**
   * Gets a single plugin skill by plugin ID and skill name
   * @param pluginId - Plugin identifier
   * @param skillName - Skill name
   * @returns Promise resolving to the plugin skill
   */
  async getPluginSkill(pluginId: string, skillName: string): Promise<PluginSkill> {
    try {
      return await invoke<PluginSkill>('get_plugin_skill', { pluginId, skillName });
    } catch (error) {
      console.error("Failed to get plugin skill:", error);
      throw error;
    }
  },

  /**
   * Gets full plugin contents (metadata, agents, commands, skills, hooks)
   * @param pluginId - Plugin identifier
   * @returns Promise resolving to the full plugin contents
   */
  async getPluginContents(pluginId: string): Promise<PluginContents> {
    try {
      return await invoke<PluginContents>('get_plugin_contents', { pluginId });
    } catch (error) {
      console.error("Failed to get plugin contents:", error);
      throw error;
    }
  },

  /**
   * Reads the Claude settings file
   * @returns Promise resolving to the settings object
   */
  async getClaudeSettings(): Promise<ClaudeSettings> {
    try {
      const result = await invoke<{ data: ClaudeSettings }>("get_claude_settings");
      console.log("Raw result from get_claude_settings:", result);
      
      // The Rust backend returns ClaudeSettings { data: ... }
      // We need to extract the data field
      if (result && typeof result === 'object' && 'data' in result) {
        return result.data;
      }
      
      // If the result is already the settings object, return it
      return result as ClaudeSettings;
    } catch (error) {
      console.error("Failed to get Claude settings:", error);
      throw error;
    }
  },

  /**
   * Opens a new Claude Code session
   * @param path - Optional path to open the session in
   * @returns Promise resolving when the session is opened
   */
  async openNewSession(path?: string): Promise<string> {
    try {
      return await invoke<string>("open_new_session", { path });
    } catch (error) {
      console.error("Failed to open new session:", error);
      throw error;
    }
  },

  /**
   * Reads the CLAUDE.md system prompt file
   * @returns Promise resolving to the system prompt content
   */
  async getSystemPrompt(): Promise<string> {
    try {
      return await invoke<string>("get_system_prompt");
    } catch (error) {
      console.error("Failed to get system prompt:", error);
      throw error;
    }
  },

  /**
   * Checks if Claude Code is installed and gets its version
   * @returns Promise resolving to the version status
   */
  async checkClaudeVersion(): Promise<ClaudeVersionStatus> {
    try {
      return await invoke<ClaudeVersionStatus>("check_claude_version");
    } catch (error) {
      console.error("Failed to check Claude version:", error);
      throw error;
    }
  },

  /**
   * Saves the CLAUDE.md system prompt file
   * @param content - The new content for the system prompt
   * @returns Promise resolving when the file is saved
   */
  async saveSystemPrompt(content: string): Promise<string> {
    try {
      return await invoke<string>("save_system_prompt", { content });
    } catch (error) {
      console.error("Failed to save system prompt:", error);
      throw error;
    }
  },

  /**
   * Gets provider-specific system prompt
   * - Claude: ~/.claude/CLAUDE.md
   * - Codex: ~/.codex/AGENTS.md
   * @param provider - The provider ID (claude, codex, etc.)
   * @returns Promise resolving to the system prompt content
   */
  async getProviderSystemPrompt(provider: string): Promise<string> {
    try {
      return await invoke<string>("get_provider_system_prompt", { provider });
    } catch (error) {
      console.error(`Failed to get system prompt for provider ${provider}:`, error);
      throw error;
    }
  },

  /**
   * Saves provider-specific system prompt
   * @param provider - The provider ID (claude, codex, etc.)
   * @param content - The new content for the system prompt
   * @returns Promise resolving when the file is saved
   */
  async saveProviderSystemPrompt(provider: string, content: string): Promise<string> {
    try {
      return await invoke<string>("save_provider_system_prompt", { provider, content });
    } catch (error) {
      console.error(`Failed to save system prompt for provider ${provider}:`, error);
      throw error;
    }
  },

  /**
   * Saves the Claude settings file
   * @param settings - The settings object to save
   * @returns Promise resolving when the settings are saved
   */
  async saveClaudeSettings(settings: ClaudeSettings): Promise<string> {
    try {
      return await invoke<string>("save_claude_settings", { settings });
    } catch (error) {
      console.error("Failed to save Claude settings:", error);
      throw error;
    }
  },

  /**
   * Finds all CLAUDE.md files in a project directory
   * @param projectPath - The absolute path to the project
   * @returns Promise resolving to an array of CLAUDE.md files
   */
  async findClaudeMdFiles(projectPath: string): Promise<ClaudeMdFile[]> {
    try {
      return await invoke<ClaudeMdFile[]>("find_claude_md_files", { projectPath });
    } catch (error) {
      console.error("Failed to find CLAUDE.md files:", error);
      throw error;
    }
  },

  /**
   * Reads a specific CLAUDE.md file
   * @param filePath - The absolute path to the file
   * @returns Promise resolving to the file content
   */
  async readClaudeMdFile(filePath: string): Promise<string> {
    try {
      return await invoke<string>("read_claude_md_file", { filePath });
    } catch (error) {
      console.error("Failed to read CLAUDE.md file:", error);
      throw error;
    }
  },

  /**
   * Saves a specific CLAUDE.md file
   * @param filePath - The absolute path to the file
   * @param content - The new content for the file
   * @returns Promise resolving when the file is saved
   */
  async saveClaudeMdFile(filePath: string, content: string): Promise<string> {
    try {
      return await invoke<string>("save_claude_md_file", { filePath, content });
    } catch (error) {
      console.error("Failed to save CLAUDE.md file:", error);
      throw error;
    }
  },

  // Agent API methods
  
  /**
   * Lists all CC agents
   * @returns Promise resolving to an array of agents
   */
  async listAgents(): Promise<Agent[]> {
    try {
      return await invoke<Agent[]>('list_agents');
    } catch (error) {
      console.error("Failed to list agents:", error);
      throw error;
    }
  },

  /**
   * Creates a new agent
   * @param name - The agent name
   * @param icon - The icon identifier
   * @param system_prompt - The system prompt for the agent
   * @param default_task - Optional default task
   * @param model - Optional model (defaults to 'sonnet')
   * @param hooks - Optional hooks configuration as JSON string
   * @returns Promise resolving to the created agent
   */
  async createAgent(
    name: string,
    icon: string,
    system_prompt: string,
    default_task?: string,
    model?: string,
    hooks?: string,
    provider_api_id?: string
  ): Promise<Agent> {
    try {
      return await invoke<Agent>('create_agent', {
        name,
        icon,
        systemPrompt: system_prompt,
        defaultTask: default_task,
        model,
        hooks,
        providerApiId: provider_api_id
      });
    } catch (error) {
      console.error("Failed to create agent:", error);
      throw error;
    }
  },

  /**
   * Updates an existing agent
   * @param id - The agent ID
   * @param name - The updated name
   * @param icon - The updated icon
   * @param system_prompt - The updated system prompt
   * @param default_task - Optional default task
   * @param model - Optional model
   * @param hooks - Optional hooks configuration as JSON string
   * @returns Promise resolving to the updated agent
   */
  async updateAgent(
    id: number,
    name: string,
    icon: string,
    system_prompt: string,
    default_task?: string,
    model?: string,
    hooks?: string,
    provider_api_id?: string
  ): Promise<Agent> {
    try {
      return await invoke<Agent>('update_agent', {
        id,
        name,
        icon,
        systemPrompt: system_prompt,
        defaultTask: default_task,
        model,
        hooks,
        providerApiId: provider_api_id
      });
    } catch (error) {
      console.error("Failed to update agent:", error);
      throw error;
    }
  },

  /**
   * Deletes an agent
   * @param id - The agent ID to delete
   * @returns Promise resolving when the agent is deleted
   */
  async deleteAgent(id: number): Promise<void> {
    try {
      return await invoke('delete_agent', { id });
    } catch (error) {
      console.error("Failed to delete agent:", error);
      throw error;
    }
  },

  /**
   * Gets a single agent by ID
   * @param id - The agent ID
   * @returns Promise resolving to the agent
   */
  async getAgent(id: number): Promise<Agent> {
    try {
      return await invoke<Agent>('get_agent', { id });
    } catch (error) {
      console.error("Failed to get agent:", error);
      throw error;
    }
  },

  /**
   * Exports a single agent to JSON format
   * @param id - The agent ID to export
   * @returns Promise resolving to the JSON string
   */
  async exportAgent(id: number): Promise<string> {
    try {
      return await invoke<string>('export_agent', { id });
    } catch (error) {
      console.error("Failed to export agent:", error);
      throw error;
    }
  },

  /**
   * Imports an agent from JSON data
   * @param jsonData - The JSON string containing the agent export
   * @returns Promise resolving to the imported agent
   */
  async importAgent(jsonData: string): Promise<Agent> {
    try {
      return await invoke<Agent>('import_agent', { jsonData });
    } catch (error) {
      console.error("Failed to import agent:", error);
      throw error;
    }
  },

  /**
   * Imports an agent from a file
   * @param filePath - The path to the JSON file
   * @returns Promise resolving to the imported agent
   */
  async importAgentFromFile(filePath: string): Promise<Agent> {
    try {
      return await invoke<Agent>('import_agent_from_file', { filePath });
    } catch (error) {
      console.error("Failed to import agent from file:", error);
      throw error;
    }
  },

  /**
   * Executes an agent
   * @param agentId - The agent ID to execute
   * @param projectPath - The project path to run the agent in
   * @param task - The task description
   * @param model - Optional model override
   * @returns Promise resolving to the run ID when execution starts
   */
  async executeAgent(agentId: number, projectPath: string, task: string, model?: string): Promise<number> {
    try {
      return await invoke<number>('execute_agent', { agentId, projectPath, task, model });
    } catch (error) {
      console.error("Failed to execute agent:", error);
      // Return a sentinel value to indicate error
      throw new Error(`Failed to execute agent: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Lists agent runs without metrics (basic info only)
   * @param agentId - Optional agent ID to filter runs
   * @returns Promise resolving to an array of agent runs
   */
  async listAgentRuns(agentId?: number): Promise<AgentRunWithMetrics[]> {
    try {
      return await invoke<AgentRunWithMetrics[]>('list_agent_runs', { agentId });
    } catch (error) {
      console.error("Failed to list agent runs:", error);
      // Return empty array instead of throwing to prevent UI crashes
      return [];
    }
  },

  /**
   * Lists agent runs with metrics (includes token counts and duration)
   * @param agentId - Optional agent ID to filter runs
   * @returns Promise resolving to an array of agent runs with metrics
   */
  async listAgentRunsWithMetrics(agentId?: number): Promise<AgentRunWithMetrics[]> {
    try {
      return await invoke<AgentRunWithMetrics[]>('list_agent_runs_with_metrics', { agentId });
    } catch (error) {
      console.error("Failed to list agent runs with metrics:", error);
      // Return empty array instead of throwing to prevent UI crashes
      return [];
    }
  },

  /**
   * Gets a single agent run by ID with metrics
   * @param id - The run ID
   * @returns Promise resolving to the agent run with metrics
   */
  async getAgentRun(id: number): Promise<AgentRunWithMetrics> {
    try {
      return await invoke<AgentRunWithMetrics>('get_agent_run', { id });
    } catch (error) {
      console.error("Failed to get agent run:", error);
      throw new Error(`Failed to get agent run: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Gets a single agent run by ID with real-time metrics from JSONL
   * @param id - The run ID
   * @returns Promise resolving to the agent run with metrics
   */
  async getAgentRunWithRealTimeMetrics(id: number): Promise<AgentRunWithMetrics> {
    try {
      return await invoke<AgentRunWithMetrics>('get_agent_run_with_real_time_metrics', { id });
    } catch (error) {
      console.error("Failed to get agent run with real-time metrics:", error);
      throw new Error(`Failed to get agent run with real-time metrics: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Lists all currently running agent sessions
   * @returns Promise resolving to list of running agent sessions
   */
  async listRunningAgentSessions(): Promise<AgentRun[]> {
    try {
      return await invoke<AgentRun[]>('list_running_sessions');
    } catch (error) {
      console.error("Failed to list running agent sessions:", error);
      throw new Error(`Failed to list running agent sessions: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Kills a running agent session
   * @param runId - The run ID to kill
   * @returns Promise resolving to whether the session was successfully killed
   */
  async killAgentSession(runId: number): Promise<boolean> {
    try {
      return await invoke<boolean>('kill_agent_session', { runId });
    } catch (error) {
      console.error("Failed to kill agent session:", error);
      throw new Error(`Failed to kill agent session: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Gets the status of a specific agent session
   * @param runId - The run ID to check
   * @returns Promise resolving to the session status or null if not found
   */
  async getSessionStatus(runId: number): Promise<string | null> {
    try {
      return await invoke<string | null>('get_session_status', { runId });
    } catch (error) {
      console.error("Failed to get session status:", error);
      throw new Error(`Failed to get session status: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Cleanup finished processes and update their status
   * @returns Promise resolving to list of run IDs that were cleaned up
   */
  async cleanupFinishedProcesses(): Promise<number[]> {
    try {
      return await invoke<number[]>('cleanup_finished_processes');
    } catch (error) {
      console.error("Failed to cleanup finished processes:", error);
      throw new Error(`Failed to cleanup finished processes: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Get real-time output for a running session (with live output fallback)
   * @param runId - The run ID to get output for
   * @returns Promise resolving to the current session output (JSONL format)
   */
  async getSessionOutput(runId: number): Promise<string> {
    try {
      return await invoke<string>('get_session_output', { runId });
    } catch (error) {
      console.error("Failed to get session output:", error);
      throw new Error(`Failed to get session output: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Get live output directly from process stdout buffer
   * @param runId - The run ID to get live output for
   * @returns Promise resolving to the current live output
   */
  async getLiveSessionOutput(runId: number): Promise<string> {
    try {
      return await invoke<string>('get_live_session_output', { runId });
    } catch (error) {
      console.error("Failed to get live session output:", error);
      throw new Error(`Failed to get live session output: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Get message index for a session (lightweight metadata only)
   * @param runId - The run ID to get message index for
   * @returns Promise resolving to an array of message metadata
   */
  async getSessionMessageIndex(runId: number): Promise<MessageIndex[]> {
    try {
      return await invoke<MessageIndex[]>('get_session_message_index', { runId });
    } catch (error) {
      console.error("Failed to get session message index:", error);
      throw new Error(`Failed to get session message index: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Get a range of messages from a session by line numbers
   * @param runId - The run ID to get messages for
   * @param startLine - Starting line number (inclusive)
   * @param endLine - Ending line number (exclusive)
   * @returns Promise resolving to an array of JSONL message strings
   */
  async getSessionMessagesRange(runId: number, startLine: number, endLine: number): Promise<string[]> {
    try {
      return await invoke<string[]>('get_session_messages_range', { runId, startLine, endLine });
    } catch (error) {
      console.error("Failed to get session messages range:", error);
      throw new Error(`Failed to get session messages range: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Start streaming real-time output for a running session
   * @param runId - The run ID to stream output for
   * @returns Promise that resolves when streaming starts
   */
  async streamSessionOutput(runId: number): Promise<void> {
    try {
      return await invoke<void>('stream_session_output', { runId });
    } catch (error) {
      console.error("Failed to start streaming session output:", error);
      throw new Error(`Failed to start streaming session output: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },

  /**
   * Loads the JSONL history for a specific session
   */
  async loadSessionHistory(sessionId: string, projectId: string): Promise<any[]> {
    return invoke("load_session_history", { sessionId, projectId });
  },

  /**
   * Loads the JSONL history for a specific agent session
   * Similar to loadSessionHistory but searches across all project directories
   * @param sessionId - The session ID (UUID)
   * @returns Promise resolving to array of session messages
   */
  async loadAgentSessionHistory(sessionId: string): Promise<any[]> {
    try {
      return await invoke<any[]>('load_agent_session_history', { sessionId });
    } catch (error) {
      console.error("Failed to load agent session history:", error);
      throw error;
    }
  },

  /**
   * Executes a new interactive Claude Code session with streaming output
   */
  async executeClaudeCode(projectPath: string, prompt: string, model: string, systemPrompt?: string, providerApiId?: string | null): Promise<void> {
    return invoke("execute_claude_code", { projectPath, prompt, model, systemPrompt, providerApiId: providerApiId || undefined });
  },

  /**
   * Starts a new provider session with streaming output
   * @param providerId - The provider ID (e.g., "claude", "codex")
   * @param projectPath - The project path
   * @param prompt - The user prompt
   * @param model - The model to use
   * @param providerApiId - Optional provider API configuration ID
   * @param thinkingMode - Optional thinking mode (e.g., "auto", "think", "think_hard", "think_harder", "ultrathink")
   */
  async startProviderSession(providerId: string, projectPath: string, prompt: string, model: string, providerApiId?: string | null, thinkingMode?: string): Promise<void> {
    return invoke("provider_start_session", {
      providerId,
      request: {
        project_path: projectPath,
        prompt,
        model,
        provider_api_id: providerApiId || undefined,
        thinking_mode: thinkingMode || undefined,
      },
    });
  },

  /**
   * Resumes an existing provider session with a new prompt
   * @param providerId - The provider ID (e.g., "claude", "codex")
   * @param sessionId - The session ID to resume
   * @param projectPath - The project path
   * @param prompt - The new prompt to send
   * @param model - The model to use
   * @param thinkingMode - Optional thinking mode (e.g., "auto", "think", "think_hard", "think_harder", "ultrathink")
   */
  async resumeProviderSession(providerId: string, sessionId: string, projectPath: string, prompt: string, model: string, thinkingMode?: string): Promise<void> {
    return invoke("provider_resume_session", {
      providerId,
      sessionId,
      projectPath,
      prompt,
      model,
      thinkingMode: thinkingMode || undefined,
    });
  },

  /**
   * Continues an existing Claude Code conversation with streaming output
   */
  async continueClaudeCode(projectPath: string, prompt: string, model: string): Promise<void> {
    return invoke("continue_claude_code", { projectPath, prompt, model });
  },

  /**
   * Resumes an existing Claude Code session by ID with streaming output
   */
  async resumeClaudeCode(projectPath: string, sessionId: string, prompt: string, model: string, systemPrompt?: string, providerApiId?: string | null): Promise<void> {
    return invoke("resume_claude_code", { projectPath, sessionId, prompt, model, systemPrompt, providerApiId: providerApiId || undefined });
  },

  /**
   * Cancels the currently running Claude Code execution
   * @param sessionId - Optional session ID to cancel a specific session
   */
  async cancelClaudeExecution(sessionId?: string): Promise<void> {
    return invoke("cancel_claude_execution", { sessionId });
  },

  /**
   * Cancels Claude execution by project path (recommended method)
   * Uses project_path as the key for faster and more reliable cancellation
   * @param projectPath - The project path to cancel execution for
   */
  async cancelClaudeExecutionByProject(projectPath: string): Promise<void> {
    return invoke("cancel_claude_execution_by_project", { projectPath });
  },

  /**
   * Checks if a Claude session is currently running by querying ProcessRegistry
   * This provides the actual process state, not event-driven state
   * @param sessionId - The session ID to check
   * @returns Promise resolving to true if the session is running, false otherwise
   */
  async isClaudeSessionRunning(sessionId: string): Promise<boolean> {
    try {
      return await invoke<boolean>("is_claude_session_running", { sessionId });
    } catch (err) {
      console.error("Failed to check Claude session status:", err);
      return false;
    }
  },

  /**
   * Checks if any provider session is running for a specific project path
   * This is more reliable than session ID based checking as project path doesn't change
   * @param projectPath - The project path to check
   * @param providerId - Provider ID (claude, codex, etc.) - defaults to "claude" for backward compatibility
   * @returns Promise resolving to true if any session is running, false otherwise
   */
  async isClaudeSessionRunningForProject(projectPath: string, providerId?: string): Promise<boolean> {
    try {
      return await invoke<boolean>("is_claude_session_running_for_project", { projectPath, providerId });
    } catch (err) {
      console.error("Failed to check provider session status for project:", err);
      return false;
    }
  },

  /**
   * Lists all currently running Claude sessions
   * @returns Promise resolving to list of running Claude sessions
   */
  async listRunningClaudeSessions(): Promise<any[]> {
    return invoke("list_running_claude_sessions");
  },

  /**
   * Gets live output from a Claude session
   * @param sessionId - The session ID to get output for
   * @returns Promise resolving to the current live output
   */
  async getClaudeSessionOutput(sessionId: string): Promise<string> {
    return invoke("get_claude_session_output", { sessionId });
  },

  /**
   * Lists files and directories in a given path
   */
  async listDirectoryContents(directoryPath: string): Promise<FileEntry[]> {
    return invoke("list_directory_contents", { directoryPath });
  },

  /**
   * Searches for files and directories matching a pattern
   */
  async searchFiles(basePath: string, query: string): Promise<FileEntry[]> {
    return invoke("search_files", { basePath, query });
  },

  /**
   * Lists Claude CLI agents from ~/.claude/agents/ directory
   */
  async listClaudeAgents(): Promise<FileEntry[]> {
    return invoke("list_claude_agents");
  },

  /**
   * Searches for Claude CLI agents matching a pattern
   */
  async searchClaudeAgents(query: string): Promise<FileEntry[]> {
    return invoke("search_claude_agents", { query });
  },

  /**
   * Gets overall usage statistics
   * @returns Promise resolving to usage statistics
   */
  async getUsageStats(): Promise<UsageStats> {
    try {
      return await invoke<UsageStats>("get_usage_stats");
    } catch (error) {
      console.error("Failed to get usage stats:", error);
      throw error;
    }
  },

  /**
   * Gets usage statistics filtered by date range
   * @param startDate - Start date (ISO format)
   * @param endDate - End date (ISO format)
   * @returns Promise resolving to usage statistics
   */
  async getUsageByDateRange(startDate: string, endDate: string): Promise<UsageStats> {
    try {
      return await invoke<UsageStats>("get_usage_by_date_range", { startDate, endDate });
    } catch (error) {
      console.error("Failed to get usage by date range:", error);
      throw error;
    }
  },

  /**
   * Gets usage statistics grouped by session
   * @param since - Optional start date (YYYYMMDD)
   * @param until - Optional end date (YYYYMMDD)
   * @param order - Optional sort order ('asc' or 'desc')
   * @returns Promise resolving to an array of session usage data
   */
  async getSessionStats(
    since?: string,
    until?: string,
    order?: "asc" | "desc"
  ): Promise<ProjectUsage[]> {
    try {
      return await invoke<ProjectUsage[]>("get_session_stats", {
        since,
        until,
        order,
      });
    } catch (error) {
      console.error("Failed to get session stats:", error);
      throw error;
    }
  },

  /**
   * Gets detailed usage entries with optional filtering
   * @param limit - Optional limit for number of entries
   * @returns Promise resolving to array of usage entries
   */
  async getUsageDetails(limit?: number): Promise<UsageEntry[]> {
    try {
      return await invoke<UsageEntry[]>("get_usage_details", { limit });
    } catch (error) {
      console.error("Failed to get usage details:", error);
      throw error;
    }
  },

  /**
   * Creates a checkpoint for the current session state
   */
  async createCheckpoint(
    sessionId: string,
    projectId: string,
    projectPath: string,
    messageIndex?: number,
    description?: string
  ): Promise<CheckpointResult> {
    return invoke("create_checkpoint", {
      sessionId,
      projectId,
      projectPath,
      messageIndex,
      description
    });
  },

  /**
   * Restores a session to a specific checkpoint
   */
  async restoreCheckpoint(
    checkpointId: string,
    sessionId: string,
    projectId: string,
    projectPath: string
  ): Promise<CheckpointResult> {
    return invoke("restore_checkpoint", {
      checkpointId,
      sessionId,
      projectId,
      projectPath
    });
  },

  /**
   * Lists all checkpoints for a session
   */
  async listCheckpoints(
    sessionId: string,
    projectId: string,
    projectPath: string
  ): Promise<Checkpoint[]> {
    return invoke("list_checkpoints", {
      sessionId,
      projectId,
      projectPath
    });
  },

  /**
   * Forks a new timeline branch from a checkpoint
   */
  async forkFromCheckpoint(
    checkpointId: string,
    sessionId: string,
    projectId: string,
    projectPath: string,
    newSessionId: string,
    description?: string
  ): Promise<CheckpointResult> {
    return invoke("fork_from_checkpoint", {
      checkpointId,
      sessionId,
      projectId,
      projectPath,
      newSessionId,
      description
    });
  },

  /**
   * Gets the timeline for a session
   */
  async getSessionTimeline(
    sessionId: string,
    projectId: string,
    projectPath: string
  ): Promise<SessionTimeline> {
    return invoke("get_session_timeline", {
      sessionId,
      projectId,
      projectPath
    });
  },

  /**
   * Updates checkpoint settings for a session
   */
  async updateCheckpointSettings(
    sessionId: string,
    projectId: string,
    projectPath: string,
    autoCheckpointEnabled: boolean,
    checkpointStrategy: CheckpointStrategy
  ): Promise<void> {
    return invoke("update_checkpoint_settings", {
      sessionId,
      projectId,
      projectPath,
      autoCheckpointEnabled,
      checkpointStrategy
    });
  },

  /**
   * Gets diff between two checkpoints
   */
  async getCheckpointDiff(
    fromCheckpointId: string,
    toCheckpointId: string,
    sessionId: string,
    projectId: string
  ): Promise<CheckpointDiff> {
    try {
      return await invoke<CheckpointDiff>("get_checkpoint_diff", {
        fromCheckpointId,
        toCheckpointId,
        sessionId,
        projectId
      });
    } catch (error) {
      console.error("Failed to get checkpoint diff:", error);
      throw error;
    }
  },

  /**
   * Tracks a message for checkpointing
   */
  async trackCheckpointMessage(
    sessionId: string,
    projectId: string,
    projectPath: string,
    message: string
  ): Promise<void> {
    try {
      await invoke("track_checkpoint_message", {
        sessionId,
        projectId,
        projectPath,
        message
      });
    } catch (error) {
      console.error("Failed to track checkpoint message:", error);
      throw error;
    }
  },

  /**
   * Checks if auto-checkpoint should be triggered
   */
  async checkAutoCheckpoint(
    sessionId: string,
    projectId: string,
    projectPath: string,
    message: string
  ): Promise<boolean> {
    try {
      return await invoke<boolean>("check_auto_checkpoint", {
        sessionId,
        projectId,
        projectPath,
        message
      });
    } catch (error) {
      console.error("Failed to check auto checkpoint:", error);
      throw error;
    }
  },

  /**
   * Triggers cleanup of old checkpoints
   */
  async cleanupOldCheckpoints(
    sessionId: string,
    projectId: string,
    projectPath: string,
    keepCount: number
  ): Promise<number> {
    try {
      return await invoke<number>("cleanup_old_checkpoints", {
        sessionId,
        projectId,
        projectPath,
        keepCount
      });
    } catch (error) {
      console.error("Failed to cleanup old checkpoints:", error);
      throw error;
    }
  },

  /**
   * Gets checkpoint settings for a session
   */
  async getCheckpointSettings(
    sessionId: string,
    projectId: string,
    projectPath: string
  ): Promise<{
    auto_checkpoint_enabled: boolean;
    checkpoint_strategy: CheckpointStrategy;
    total_checkpoints: number;
    current_checkpoint_id?: string;
  }> {
    try {
      return await invoke("get_checkpoint_settings", {
        sessionId,
        projectId,
        projectPath
      });
    } catch (error) {
      console.error("Failed to get checkpoint settings:", error);
      throw error;
    }
  },

  /**
   * Clears checkpoint manager for a session (cleanup on session end)
   */
  async clearCheckpointManager(sessionId: string): Promise<void> {
    try {
      await invoke("clear_checkpoint_manager", { sessionId });
    } catch (error) {
      console.error("Failed to clear checkpoint manager:", error);
      throw error;
    }
  },

  /**
   * Tracks a batch of messages for a session for checkpointing
   */
  trackSessionMessages: (
    sessionId: string, 
    projectId: string, 
    projectPath: string, 
    messages: string[]
  ): Promise<void> =>
    invoke("track_session_messages", { sessionId, projectId, projectPath, messages }),

  /**
   * Adds a new MCP server
   */
  async mcpAdd(
    name: string,
    transport: string,
    command?: string,
    args: string[] = [],
    env: Record<string, string> = {},
    url?: string,
    scope: string = "local"
  ): Promise<AddServerResult> {
    try {
      return await invoke<AddServerResult>("mcp_add", {
        name,
        transport,
        command,
        args,
        env,
        url,
        scope
      });
    } catch (error) {
      console.error("Failed to add MCP server:", error);
      throw error;
    }
  },

  /**
   * Lists all configured MCP servers
   */
  async mcpList(): Promise<MCPServer[]> {
    try {
      console.log("API: Calling mcp_list...");
      const result = await invoke<MCPServer[]>("mcp_list");
      console.log("API: mcp_list returned:", result);
      return result;
    } catch (error) {
      console.error("API: Failed to list MCP servers:", error);
      throw error;
    }
  },

  /**
   * Gets details for a specific MCP server
   */
  async mcpGet(name: string): Promise<MCPServer> {
    try {
      return await invoke<MCPServer>("mcp_get", { name });
    } catch (error) {
      console.error("Failed to get MCP server:", error);
      throw error;
    }
  },

  /**
   * Removes an MCP server
   */
  async mcpRemove(name: string): Promise<string> {
    try {
      return await invoke<string>("mcp_remove", { name });
    } catch (error) {
      console.error("Failed to remove MCP server:", error);
      throw error;
    }
  },

  /**
   * Adds an MCP server from JSON configuration
   */
  async mcpAddJson(name: string, jsonConfig: string, scope: string = "local"): Promise<AddServerResult> {
    try {
      return await invoke<AddServerResult>("mcp_add_json", { name, jsonConfig, scope });
    } catch (error) {
      console.error("Failed to add MCP server from JSON:", error);
      throw error;
    }
  },

  /**
   * Imports MCP servers from Claude Desktop
   */
  async mcpAddFromClaudeDesktop(scope: string = "local"): Promise<ImportResult> {
    try {
      return await invoke<ImportResult>("mcp_add_from_claude_desktop", { scope });
    } catch (error) {
      console.error("Failed to import from Claude Desktop:", error);
      throw error;
    }
  },

  /**
   * Starts Claude Code as an MCP server
   */
  async mcpServe(): Promise<string> {
    try {
      return await invoke<string>("mcp_serve");
    } catch (error) {
      console.error("Failed to start MCP server:", error);
      throw error;
    }
  },

  /**
   * Tests connection to an MCP server
   */
  async mcpTestConnection(name: string): Promise<string> {
    try {
      return await invoke<string>("mcp_test_connection", { name });
    } catch (error) {
      console.error("Failed to test MCP connection:", error);
      throw error;
    }
  },

  /**
   * Resets project-scoped server approval choices
   */
  async mcpResetProjectChoices(): Promise<string> {
    try {
      return await invoke<string>("mcp_reset_project_choices");
    } catch (error) {
      console.error("Failed to reset project choices:", error);
      throw error;
    }
  },

  /**
   * Gets the status of MCP servers
   */
  async mcpGetServerStatus(): Promise<Record<string, ServerStatus>> {
    try {
      return await invoke<Record<string, ServerStatus>>("mcp_get_server_status");
    } catch (error) {
      console.error("Failed to get server status:", error);
      throw error;
    }
  },

  /**
   * Reads .mcp.json from the current project
   */
  async mcpReadProjectConfig(projectPath: string): Promise<MCPProjectConfig> {
    try {
      return await invoke<MCPProjectConfig>("mcp_read_project_config", { projectPath });
    } catch (error) {
      console.error("Failed to read project MCP config:", error);
      throw error;
    }
  },

  /**
   * Saves .mcp.json to the current project
   */
  async mcpSaveProjectConfig(projectPath: string, config: MCPProjectConfig): Promise<string> {
    try {
      return await invoke<string>("mcp_save_project_config", { projectPath, config });
    } catch (error) {
      console.error("Failed to save project MCP config:", error);
      throw error;
    }
  },

  /**
   * Get the stored Claude binary path from settings
   * @returns Promise resolving to the path if set, null otherwise
   */
  async getClaudeBinaryPath(): Promise<string | null> {
    try {
      return await invoke<string | null>("get_claude_binary_path");
    } catch (error) {
      console.error("Failed to get Claude binary path:", error);
      throw error;
    }
  },

  /**
   * Set the Claude binary path in settings
   * @param path - The absolute path to the Claude binary
   * @returns Promise resolving when the path is saved
   */
  async setClaudeBinaryPath(path: string): Promise<void> {
    try {
      return await invoke<void>("set_claude_binary_path", { path });
    } catch (error) {
      console.error("Failed to set Claude binary path:", error);
      throw error;
    }
  },

  /**
   * List all available Claude installations on the system
   * @returns Promise resolving to an array of Claude installations
   */
  async listClaudeInstallations(): Promise<ClaudeInstallation[]> {
    try {
      return await invoke<ClaudeInstallation[]>("list_claude_installations");
    } catch (error) {
      console.error("Failed to list Claude installations:", error);
      throw error;
    }
  },

  // Storage API methods

  /**
   * Lists all tables in the SQLite database
   * @returns Promise resolving to an array of table information
   */
  async storageListTables(): Promise<any[]> {
    try {
      return await invoke<any[]>("storage_list_tables");
    } catch (error) {
      console.error("Failed to list tables:", error);
      throw error;
    }
  },

  /**
   * Reads table data with pagination
   * @param tableName - Name of the table to read
   * @param page - Page number (1-indexed)
   * @param pageSize - Number of rows per page
   * @param searchQuery - Optional search query
   * @returns Promise resolving to table data with pagination info
   */
  async storageReadTable(
    tableName: string,
    page: number,
    pageSize: number,
    searchQuery?: string
  ): Promise<any> {
    try {
      return await invoke<any>("storage_read_table", {
        tableName,
        page,
        pageSize,
        searchQuery,
      });
    } catch (error) {
      console.error("Failed to read table:", error);
      throw error;
    }
  },

  /**
   * Updates a row in a table
   * @param tableName - Name of the table
   * @param primaryKeyValues - Map of primary key column names to values
   * @param updates - Map of column names to new values
   * @returns Promise resolving when the row is updated
   */
  async storageUpdateRow(
    tableName: string,
    primaryKeyValues: Record<string, any>,
    updates: Record<string, any>
  ): Promise<void> {
    try {
      return await invoke<void>("storage_update_row", {
        tableName,
        primaryKeyValues,
        updates,
      });
    } catch (error) {
      console.error("Failed to update row:", error);
      throw error;
    }
  },

  /**
   * Deletes a row from a table
   * @param tableName - Name of the table
   * @param primaryKeyValues - Map of primary key column names to values
   * @returns Promise resolving when the row is deleted
   */
  async storageDeleteRow(
    tableName: string,
    primaryKeyValues: Record<string, any>
  ): Promise<void> {
    try {
      return await invoke<void>("storage_delete_row", {
        tableName,
        primaryKeyValues,
      });
    } catch (error) {
      console.error("Failed to delete row:", error);
      throw error;
    }
  },

  /**
   * Inserts a new row into a table
   * @param tableName - Name of the table
   * @param values - Map of column names to values
   * @returns Promise resolving to the last insert row ID
   */
  async storageInsertRow(
    tableName: string,
    values: Record<string, any>
  ): Promise<number> {
    try {
      return await invoke<number>("storage_insert_row", {
        tableName,
        values,
      });
    } catch (error) {
      console.error("Failed to insert row:", error);
      throw error;
    }
  },

  /**
   * Executes a raw SQL query
   * @param query - SQL query string
   * @returns Promise resolving to query result
   */
  async storageExecuteSql(query: string): Promise<any> {
    try {
      return await invoke<any>("storage_execute_sql", { query });
    } catch (error) {
      console.error("Failed to execute SQL:", error);
      throw error;
    }
  },

  /**
   * Resets the entire database
   * @returns Promise resolving when the database is reset
   */
  async storageResetDatabase(): Promise<void> {
    try {
      return await invoke<void>("storage_reset_database");
    } catch (error) {
      console.error("Failed to reset database:", error);
      throw error;
    }
  },

  // Theme settings helpers

  /**
   * Gets a setting from the app_settings table
   * @param key - The setting key to retrieve
   * @returns Promise resolving to the setting value or null if not found
   */
  async getSetting(key: string): Promise<string | null> {
    try {
      // Fast path: check localStorage mirror to avoid startup flicker
      if (typeof window !== 'undefined' && 'localStorage' in window) {
        const cached = window.localStorage.getItem(`app_setting:${key}`);
        if (cached !== null) {
          return cached;
        }
      }
      // Use storageReadTable to safely query the app_settings table
      const result = await this.storageReadTable('app_settings', 1, 1000);
      const setting = result?.data?.find((row: any) => row.key === key);
      return setting?.value || null;
    } catch (error) {
      console.error(`Failed to get setting ${key}:`, error);
      return null;
    }
  },

  /**
   * Saves a setting to the app_settings table (insert or update)
   * @param key - The setting key
   * @param value - The setting value
   * @returns Promise resolving when the setting is saved
   */
  async saveSetting(key: string, value: string): Promise<void> {
    try {
      // Mirror to localStorage for instant availability on next startup
      if (typeof window !== 'undefined' && 'localStorage' in window) {
        try {
          window.localStorage.setItem(`app_setting:${key}`, value);
        } catch (_ignore) {
          // best-effort; continue to persist in DB
        }
      }
      // Try to update first
      try {
        await this.storageUpdateRow(
          'app_settings',
          { key },
          { value }
        );
      } catch (updateError) {
        // If update fails (row doesn't exist), insert new row
        await this.storageInsertRow('app_settings', { key, value });
      }
    } catch (error) {
      console.error(`Failed to save setting ${key}:`, error);
      throw error;
    }
  },

  /**
   * Get workspace protection enabled status
   * @returns Promise resolving to whether workspace protection is enabled
   */
  async getWorkspaceProtectionEnabled(): Promise<boolean> {
    try {
      return await invoke<boolean>("get_workspace_protection_enabled");
    } catch (error) {
      console.error("Failed to get workspace protection status:", error);
      return true; // Default to enabled
    }
  },

  /**
   * Set workspace protection enabled status
   * @param enabled - Whether to enable workspace protection
   * @returns Promise resolving when the setting is saved
   */
  async setWorkspaceProtectionEnabled(enabled: boolean): Promise<void> {
    try {
      await invoke("set_workspace_protection_enabled", { enabled });
    } catch (error) {
      console.error("Failed to set workspace protection status:", error);
      throw error;
    }
  },

  /**
   * Get hooks configuration for a specific scope
   * @param scope - The configuration scope: 'user', 'project', or 'local'
   * @param projectPath - Project path (required for project and local scopes)
   * @returns Promise resolving to the hooks configuration
   */
  async getHooksConfig(scope: 'user' | 'project' | 'local', projectPath?: string): Promise<HooksConfiguration> {
    try {
      return await invoke<HooksConfiguration>("get_hooks_config", { scope, projectPath });
    } catch (error) {
      console.error("Failed to get hooks config:", error);
      throw error;
    }
  },

  /**
   * Update hooks configuration for a specific scope
   * @param scope - The configuration scope: 'user', 'project', or 'local'
   * @param hooks - The hooks configuration to save
   * @param projectPath - Project path (required for project and local scopes)
   * @returns Promise resolving to success message
   */
  async updateHooksConfig(
    scope: 'user' | 'project' | 'local',
    hooks: HooksConfiguration,
    projectPath?: string
  ): Promise<string> {
    try {
      return await invoke<string>("update_hooks_config", { scope, projectPath, hooks });
    } catch (error) {
      console.error("Failed to update hooks config:", error);
      throw error;
    }
  },

  /**
   * Validate a hook command syntax
   * @param command - The shell command to validate
   * @returns Promise resolving to validation result
   */
  async validateHookCommand(command: string): Promise<{ valid: boolean; message: string }> {
    try {
      return await invoke<{ valid: boolean; message: string }>("validate_hook_command", { command });
    } catch (error) {
      console.error("Failed to validate hook command:", error);
      throw error;
    }
  },

  /**
   * Saves a pasted image (base64 data) to a temporary directory and returns the file path
   * @param base64Data - Base64 image data (including data URL prefix like "data:image/png;base64,...")
   * @param projectPath - The project path
   * @returns Promise resolving to the absolute path of the saved image
   */
  async savePastedImage(base64Data: string, projectPath: string): Promise<string> {
    try {
      return await invoke<string>("save_pasted_image", { base64Data, projectPath });
    } catch (error) {
      console.error("Failed to save pasted image:", error);
      throw error;
    }
  },

  /**
   * Get merged hooks configuration (respecting priority)
   * @param projectPath - The project path
   * @returns Promise resolving to merged hooks configuration
   */
  async getMergedHooksConfig(projectPath: string): Promise<HooksConfiguration> {
    try {
      const [userHooks, projectHooks, localHooks] = await Promise.all([
        this.getHooksConfig('user'),
        this.getHooksConfig('project', projectPath),
        this.getHooksConfig('local', projectPath)
      ]);

      // Import HooksManager for merging
      const { HooksManager } = await import('@/lib/hooksManager');
      return HooksManager.mergeConfigs(userHooks, projectHooks, localHooks);
    } catch (error) {
      console.error("Failed to get merged hooks config:", error);
      throw error;
    }
  },

  // Slash Commands API methods

  /**
   * Lists all available slash commands
   * @param projectPath - Optional project path to include project-specific commands
   * @returns Promise resolving to array of slash commands
   */
  async slashCommandsList(projectPath?: string): Promise<SlashCommand[]> {
    try {
      return await invoke<SlashCommand[]>("slash_commands_list", { projectPath });
    } catch (error) {
      console.error("Failed to list slash commands:", error);
      throw error;
    }
  },

  /**
   * Gets a single slash command by ID
   * @param commandId - Unique identifier of the command
   * @returns Promise resolving to the slash command
   */
  async slashCommandGet(commandId: string): Promise<SlashCommand> {
    try {
      return await invoke<SlashCommand>("slash_command_get", { commandId });
    } catch (error) {
      console.error("Failed to get slash command:", error);
      throw error;
    }
  },

  /**
   * Creates or updates a slash command
   * @param scope - Command scope: "project" or "user"
   * @param name - Command name (without prefix)
   * @param namespace - Optional namespace for organization
   * @param content - Markdown content of the command
   * @param description - Optional description
   * @param allowedTools - List of allowed tools for this command (Claude only)
   * @param argumentHint - Argument hint for documentation (Codex only)
   * @param projectPath - Required for project scope commands
   * @param commandType - Command type: "claude" or "codex" (defaults to "claude")
   * @returns Promise resolving to the saved command
   */
  async slashCommandSave(
    scope: string,
    name: string,
    namespace: string | undefined,
    content: string,
    description: string | undefined,
    allowedTools: string[],
    argumentHint: string | undefined,
    projectPath?: string,
    commandType?: CommandType
  ): Promise<SlashCommand> {
    try {
      return await invoke<SlashCommand>("slash_command_save", {
        scope,
        name,
        namespace,
        content,
        description,
        allowedTools,
        argumentHint,
        projectPath,
        commandType
      });
    } catch (error) {
      console.error("Failed to save slash command:", error);
      throw error;
    }
  },

  /**
   * Deletes a slash command
   * @param commandId - Unique identifier of the command to delete
   * @param projectPath - Optional project path for deleting project commands
   * @returns Promise resolving to deletion message
   */
  async slashCommandDelete(commandId: string, projectPath?: string): Promise<string> {
    try {
      return await invoke<string>("slash_command_delete", { commandId, projectPath });
    } catch (error) {
      console.error("Failed to delete slash command:", error);
      throw error;
    }
  },

  // ============================================================================
  // Skills Management
  // ============================================================================

  /**
   * Lists all skills (plugin + user + project)
   * @param projectPath - Optional project path for loading project-specific skills
   * @returns Promise resolving to array of skills
   */
  async skillsList(projectPath?: string): Promise<Skill[]> {
    try {
      return await invoke<Skill[]>("skills_list", { projectPath });
    } catch (error) {
      console.error("Failed to list skills:", error);
      throw error;
    }
  },

  /**
   * Gets a single skill by ID
   * @param skillId - Unique identifier of the skill
   * @param projectPath - Optional project path for project-level skills
   * @returns Promise resolving to the skill
   */
  async skillGet(skillId: string, projectPath?: string): Promise<Skill> {
    try {
      return await invoke<Skill>("skill_get", { skillId, projectPath });
    } catch (error) {
      console.error("Failed to get skill:", error);
      throw error;
    }
  },

  /**
   * Detects if the current project is a Git worktree child branch
   * @param projectPath - The project path to check
   * @returns Promise resolving to worktree information
   */
  async detectWorktree(projectPath: string): Promise<WorktreeInfo> {
    try {
      return await invoke<WorktreeInfo>("detect_worktree", { projectPath });
    } catch (error) {
      console.error("Failed to detect worktree:", error);
      throw error;
    }
  },

  /**
   * Pushes the current worktree branch to the main worktree branch (via merge)
   * @param projectPath - The project path to push from
   * @returns Promise resolving to success message
   */
  async pushToMainWorktree(projectPath: string): Promise<string> {
    try {
      return await invoke<string>("push_to_main_worktree", { projectPath });
    } catch (error) {
      console.error("Failed to push to main worktree:", error);
      throw error;
    }
  },

  /**
   * Gets the count of unpushed commits relative to the main worktree branch
   * @param projectPath - The project path to check
   * @returns Promise resolving to the count of unpushed commits
   */
  async getUnpushedCommitsCount(projectPath: string): Promise<number> {
    try {
      return await invoke<number>("get_unpushed_commits_count", { projectPath });
    } catch (error) {
      console.error("Failed to get unpushed commits count:", error);
      throw error;
    }
  },

  /**
   * Pushes the current branch to the remote repository (origin)
   * @param projectPath - The project path to push
   * @returns Promise resolving to success message
   */
  async pushToRemote(projectPath: string): Promise<string> {
    try {
      return await invoke<string>("push_to_remote", { projectPath });
    } catch (error) {
      console.error("Failed to push to remote:", error);
      throw error;
    }
  },

  /**
   * Gets the count of unpushed commits relative to the remote branch
   * @param projectPath - The project path to check
   * @returns Promise resolving to the count of unpushed commits
   */
  async getUnpushedToRemoteCount(projectPath: string): Promise<number> {
    try {
      return await invoke<number>("get_unpushed_to_remote_count", { projectPath });
    } catch (error) {
      console.error("Failed to get unpushed to remote count:", error);
      throw error;
    }
  },

  /**
   * Checks if the workspace is clean (no uncommitted changes or unpushed commits)
   * @param projectPath - The project path to check
   * @returns Promise that resolves if workspace is clean, rejects with error message if not
   */
  async checkWorkspaceClean(projectPath: string): Promise<void> {
    try {
      await invoke<void>("check_workspace_clean", { projectPath });
    } catch (error) {
      console.error("Workspace is not clean:", error);
      throw error;
    }
  },

  /**
   * Cleans up workspace: rolls back uncommitted changes, removes unpushed commits, and cleans untracked files
   * @param projectPath - The project path to clean
   * @returns Promise resolving to cleanup success message
   */
  async cleanupWorkspace(projectPath: string): Promise<string> {
    try {
      return await invoke<string>("cleanup_workspace", { projectPath });
    } catch (error) {
      console.error("Failed to cleanup workspace:", error);
      throw error;
    }
  },

  /**
   * Gets the current git branch for a given project path
   * @param projectPath - The project path to check
   * @returns Promise resolving to the current branch name
   */
  async getCurrentBranch(projectPath: string): Promise<string> {
    try {
      return await invoke<string>("get_current_branch", { projectPath });
    } catch (error) {
      console.error("Failed to get current branch:", error);
      throw error;
    }
  },

  /**
   * Updates the branch name for a workspace in the project index
   * @param workspacePath - The workspace path
   * @param branchName - The new branch name
   * @returns Promise resolving when the update is complete
   */
  async updateWorkspaceBranch(workspacePath: string, branchName: string): Promise<void> {
    try {
      await invoke<void>("update_workspace_branch", { workspacePath, branchName });
    } catch (error) {
      console.error("Failed to update workspace branch:", error);
      throw error;
    }
  },

  /**
   * Notifies all windows about a git branch rename event
   * @param workspacePath - The workspace path
   * @param branchName - The new branch name
   * @returns Promise resolving when the notification is sent
   */
  async notifyBranchRenamed(workspacePath: string, branchName: string): Promise<void> {
    try {
      await invoke<void>("notify_branch_renamed", { workspacePath, branchName });
    } catch (error) {
      console.error("Failed to notify branch rename:", error);
      throw error;
    }
  },

  /**
   * Execute a shell command (synchronous - blocks until complete)
   * @param command - The command to execute
   * @param cwd - Optional working directory
   * @returns Promise resolving to command result
   */
  async executeCommand(command: string, cwd?: string): Promise<{ success: boolean; output?: string; error?: string }> {
    try {
      const result = await invoke<{ stdout: string; stderr: string; success: boolean }>("execute_command", {
        command,
        cwd: cwd || undefined
      });
      return {
        success: result.success,
        output: result.stdout,
        error: result.stderr
      };
    } catch (error) {
      console.error("Failed to execute command:", error);
      return {
        success: false,
        error: String(error)
      };
    }
  },

  /**
   * Execute a shell command asynchronously with streaming output
   * @param commandId - Unique ID for this command
   * @param command - The command to execute
   * @param cwd - Optional working directory
   * @returns Promise resolving to command ID
   */
  async executeCommandAsync(commandId: string, command: string, cwd?: string): Promise<string> {
    try {
      const result = await invoke<string>("execute_command_async", {
        commandId,
        command,
        cwd: cwd || undefined
      });
      return result;
    } catch (error) {
      console.error("Failed to execute command async:", error);
      throw error;
    }
  },

  /**
   * Kill a running command
   * @param commandId - The command ID to kill
   */
  async killCommand(commandId: string): Promise<void> {
    try {
      await invoke<void>("kill_command", { commandId });
    } catch (error) {
      console.error("Failed to kill command:", error);
      throw error;
    }
  },

  // Actions Management API methods

  /**
   * Get all actions for a specific workspace (global + project + workspace actions)
   * @param projectName - The project name
   * @param workspaceName - Optional workspace name
   * @returns Promise resolving to global, project and workspace actions
   */
  async getActions(projectName: string, workspaceName?: string): Promise<{ global_actions: Action[]; project_actions: Action[]; workspace_actions: Action[] }> {
    try {
      return await invoke<{ global_actions: Action[]; project_actions: Action[]; workspace_actions: Action[] }>("get_actions", {
        projectName,
        workspaceName
      });
    } catch (error) {
      console.error("Failed to get actions:", error);
      throw error;
    }
  },

  /**
   * Update project-level actions
   * @param projectName - The project name
   * @param actions - The updated actions array
   * @returns Promise resolving when the update is complete
   */
  async updateProjectActions(projectName: string, actions: Action[]): Promise<void> {
    try {
      await invoke<void>("update_project_actions", {
        request: {
          project_name: projectName,
          actions
        }
      });
    } catch (error) {
      console.error("Failed to update project actions:", error);
      throw error;
    }
  },

  /**
   * Update workspace-level actions
   * @param projectName - The project name
   * @param workspaceName - The workspace name
   * @param actions - The updated actions array
   * @returns Promise resolving when the update is complete
   */
  async updateWorkspaceActions(projectName: string, workspaceName: string, actions: Action[]): Promise<void> {
    try {
      await invoke<void>("update_workspace_actions", {
        request: {
          project_name: projectName,
          workspace_name: workspaceName,
          actions
        }
      });
    } catch (error) {
      console.error("Failed to update workspace actions:", error);
      throw error;
    }
  },

  /**
   * Get global actions (available across all projects and workspaces)
   * @returns Promise resolving to global actions array
   */
  async getGlobalActions(): Promise<Action[]> {
    try {
      return await invoke<Action[]>("get_global_actions");
    } catch (error) {
      console.error("Failed to get global actions:", error);
      throw error;
    }
  },

  /**
   * Update global actions
   * @param actions - The updated global actions array
   * @returns Promise resolving when the update is complete
   */
  async updateGlobalActions(actions: Action[]): Promise<void> {
    try {
      await invoke<void>("update_global_actions", { actions });
    } catch (error) {
      console.error("Failed to update global actions:", error);
      throw error;
    }
  },

  /**
   * Opens a project/workspace path in an external application
   * @param appType - The type of application: "pycharm" | "idea" | "clion" | "android-studio" | "iterm" | "finder" | "sublime"
   * @param path - The project/workspace path to open
   * @returns Promise resolving when the application is opened
   */
  async openInExternalApp(appType: "pycharm" | "idea" | "clion" | "android-studio" | "iterm" | "finder" | "sublime", path: string): Promise<void> {
    try {
      await invoke<void>("open_in_external_app", { appType, path });
    } catch (error) {
      console.error(`Failed to open in ${appType}:`, error);
      throw error;
    }
  },

  // Provider API Configuration Methods

  /**
   * Lists all provider API configurations
   * @returns Promise resolving to array of provider API configurations
   */
  async listProviderApiConfigs(): Promise<ProviderApiConfig[]> {
    try {
      return await invoke<ProviderApiConfig[]>("list_provider_api_configs");
    } catch (error) {
      console.error("Failed to list provider API configs:", error);
      throw error;
    }
  },

  /**
   * Gets a specific provider API configuration by ID
   * @param id - The provider API configuration ID
   * @returns Promise resolving to the provider API configuration
   */
  async getProviderApiConfig(id: string): Promise<ProviderApiConfig> {
    try {
      return await invoke<ProviderApiConfig>("get_provider_api_config", { id });
    } catch (error) {
      console.error("Failed to get provider API config:", error);
      throw error;
    }
  },

  /**
   * Creates a new provider API configuration
   * @param config - The provider API configuration to create
   * @returns Promise resolving to the created provider API configuration
   */
  async createProviderApiConfig(config: Omit<ProviderApiConfig, 'created_at' | 'updated_at'>): Promise<ProviderApiConfig> {
    try {
      return await invoke<ProviderApiConfig>("create_provider_api_config", { config });
    } catch (error) {
      console.error("Failed to create provider API config:", error);
      throw error;
    }
  },

  /**
   * Updates an existing provider API configuration
   * @param id - The provider API configuration ID
   * @param config - The updated provider API configuration
   * @returns Promise resolving to the updated provider API configuration
   */
  async updateProviderApiConfig(id: string, config: Partial<Omit<ProviderApiConfig, 'id' | 'created_at' | 'updated_at'>>): Promise<ProviderApiConfig> {
    try {
      return await invoke<ProviderApiConfig>("update_provider_api_config", { id, config });
    } catch (error) {
      console.error("Failed to update provider API config:", error);
      throw error;
    }
  },

  /**
   * Deletes a provider API configuration
   * @param id - The provider API configuration ID to delete
   * @returns Promise resolving when the configuration is deleted
   */
  async deleteProviderApiConfig(id: string): Promise<void> {
    try {
      await invoke<void>("delete_provider_api_config", { id });
    } catch (error) {
      console.error("Failed to delete provider API config:", error);
      throw error;
    }
  },

  /**
   * Gets the provider API configuration ID for a specific project/workspace
   * @param projectPath - The project or workspace path
   * @param providerId - The provider ID
   * @returns Promise resolving to the provider API config ID or null
   */
  async getProjectProviderApiConfig(projectPath: string, providerId: string): Promise<string | null> {
    try {
      return await invoke<string | null>("get_project_provider_api_config", { projectPath, providerId });
    } catch (error) {
      console.error("Failed to get project provider API config:", error);
      throw error;
    }
  },

  /**
   * Sets the provider API configuration for a specific project/workspace
   * @param projectPath - The project or workspace path
   * @param providerId - The provider ID
   * @param providerApiId - The provider API configuration ID to use
   * @returns Promise resolving when the configuration is set
   */
  async setProjectProviderApiConfig(projectPath: string, providerId: string, providerApiId: string): Promise<void> {
    try {
      await invoke<void>("set_project_provider_api_config", { projectPath, providerId, providerApiId });
    } catch (error) {
      console.error("Failed to set project provider API config:", error);
      throw error;
    }
  },

  // ==================== PTY Terminal API ====================

  /**
   * Create a new PTY session for interactive terminal
   * @param sessionId - Unique session identifier
   * @param cwd - Optional working directory
   * @param rows - Terminal rows (default: 24)
   * @param cols - Terminal columns (default: 80)
   * @param shell - Optional shell path
   * @returns Promise resolving to session info
   */
  async createPtySession(
    sessionId: string,
    cwd?: string,
    rows?: number,
    cols?: number,
    shell?: string
  ): Promise<{ sessionId: string; cwd: string; shell: string; rows: number; cols: number }> {
    return invoke("create_pty_session", {
      sessionId,
      cwd,
      rows,
      cols,
      shell,
    });
  },

  /**
   * Write input to PTY session
   * @param sessionId - Session identifier
   * @param data - Input data to write
   */
  async writeToPty(sessionId: string, data: string): Promise<void> {
    return invoke("write_to_pty", {
      sessionId,
      data,
    });
  },

  /**
   * Resize PTY terminal
   * @param sessionId - Session identifier
   * @param rows - New number of rows
   * @param cols - New number of columns
   */
  async resizePty(sessionId: string, rows: number, cols: number): Promise<void> {
    return invoke("resize_pty", {
      sessionId,
      rows,
      cols,
    });
  },

  /**
   * Close PTY session
   * @param sessionId - Session identifier
   */
  async closePtySession(sessionId: string): Promise<void> {
    return invoke("close_pty_session", { sessionId });
  },

  /**
   * List all active PTY sessions
   * @returns Promise resolving to array of session IDs
   */
  async listPtySessions(): Promise<string[]> {
    return invoke("list_pty_sessions");
  },

  /**
   * Check if PTY session is alive
   * @param sessionId - Session identifier
   * @returns Promise resolving to boolean
   */
  async isPtySessionAlive(sessionId: string): Promise<boolean> {
    return invoke("is_pty_session_alive", { sessionId });
  },

  /**
   * Sync a project from SSH server using SFTP
   * @param config - SSH configuration
   * @param onProgress - Optional callback for progress updates
   * @returns Promise resolving to the created project
   */
  async syncFromSSH(
    config: SSHConfig,
    onProgress?: (progress: SSHSyncProgress) => void
  ): Promise<Project> {
    try {
      // Set up event listener for progress updates if callback provided
      let unlisten: (() => void) | undefined;

      if (onProgress) {
        const { listen } = await import('@tauri-apps/api/event');
        unlisten = await listen<SSHSyncProgress>('ssh-sync-progress', (event) => {
          onProgress(event.payload);
        });
      }

      try {
        // Invoke the Rust command
        const project = await invoke<Project>('sync_from_ssh', { config });
        return project;
      } finally {
        // Clean up event listener
        if (unlisten) {
          unlisten();
        }
      }
    } catch (error) {
      console.error("Failed to sync from SSH:", error);
      throw error;
    }
  },

  /** Pause SSH sync by id */
  async pauseSshSync(syncId: string): Promise<void> {
    await invoke("ssh_sync_pause", { syncId });
  },
  /** Resume SSH sync by id */
  async resumeSshSync(syncId: string): Promise<void> {
    await invoke("ssh_sync_resume", { syncId });
  },
  /** Cancel SSH sync by id */
  async cancelSshSync(syncId: string): Promise<void> {
    await invoke("ssh_sync_cancel", { syncId });
  },

  /** List globally saved SSH connections */
  async listGlobalSshConnections(): Promise<any[]> {
    return invoke("list_global_ssh_connections");
  },
  /** Add or update a global SSH connection */
  async addGlobalSshConnection(conn: any): Promise<void> {
    return invoke("add_global_ssh_connection", { conn });
  },
  async deleteGlobalSshConnection(name: string): Promise<void> {
    return invoke("delete_global_ssh_connection", { name });
  },
  async testSshConnection(conn: { host: string; port: number; username: string; authMethod: SSHAuthMethod }): Promise<void> {
    return invoke("test_ssh_connection", { conn });
  },

  /**
   * Start auto sync for a project
   * @param projectId - Unique identifier for the project
   * @param config - SSH configuration for auto sync
   */
  async startAutoSync(projectId: string, config: SSHConfig): Promise<void> {
    return invoke("start_auto_sync", { projectId, config });
  },

  /**
   * Stop auto sync for a project
   * @param projectId - Unique identifier for the project
   */
  async stopAutoSync(projectId: string): Promise<void> {
    return invoke("stop_auto_sync", { projectId });
  },

  /**
   * Get auto sync status for a project
   * @param projectId - Unique identifier for the project
   * @returns Auto sync status
   */
  async getAutoSyncStatus(projectId: string): Promise<AutoSyncStatus> {
    return invoke("get_auto_sync_status", { projectId });
  },

  /**
   * Clone a Git repository
   * @param config - Git clone configuration
   * @param onProgress - Optional callback for progress updates
   * @returns Promise resolving to the created project
   */
  async cloneRepository(
    config: GitCloneConfig,
    onProgress?: (progress: GitCloneProgress) => void
  ): Promise<Project> {
    try {
      // Set up event listener for progress updates if callback provided
      let unlisten: (() => void) | undefined;

      if (onProgress) {
        const { listen } = await import('@tauri-apps/api/event');
        unlisten = await listen<GitCloneProgress>('git-clone-progress', (event) => {
          onProgress(event.payload);
        });
      }

      try {
        // Invoke the Rust command
        const project = await invoke<Project>('clone_repository', { config });
        return project;
      } finally {
        // Clean up event listener
        if (unlisten) {
          unlisten();
        }
      }
    } catch (error) {
      console.error("Failed to clone repository:", error);
      throw error;
    }
  },

  async initLocalGit(projectPath: string, commitAllFiles: boolean = false): Promise<void> {
    try {
      await invoke('init_local_git', { projectPath, commitAllFiles });
    } catch (error) {
      console.error("Failed to initialize local git:", error);
      throw error;
    }
  },

  async isGitRepository(path: string): Promise<boolean> {
    try {
      return await invoke<boolean>('is_git_repository', { path });
    } catch (error) {
      console.error("Failed to check git repository:", error);
      throw error;
    }
  },

};
